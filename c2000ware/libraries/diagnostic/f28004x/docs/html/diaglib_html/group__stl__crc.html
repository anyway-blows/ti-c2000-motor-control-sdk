<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>CRC API Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="$relpath/search.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<!-- Generated by Doxygen 1.8.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CRC API Functions</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_s_t_l___c_r_c___obj.html">STL_CRC_Obj</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CRC structure.  <a href="struct_s_t_l___c_r_c___obj.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaa767de3bcc0ddcc991684de95fd7a763"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stl__crc.html#gaa767de3bcc0ddcc991684de95fd7a763">STL_CRC_INIT_CRC</a>&#160;&#160;&#160;0x0UL</td></tr>
<tr class="memdesc:gaa767de3bcc0ddcc991684de95fd7a763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial CRC Register Value.  <a href="#gaa767de3bcc0ddcc991684de95fd7a763">More...</a><br/></td></tr>
<tr class="separator:gaa767de3bcc0ddcc991684de95fd7a763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c12c9f4560937e82ca07044f9f9ed78"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stl__crc.html#ga5c12c9f4560937e82ca07044f9f9ed78">STL_CRC_PASS</a>&#160;&#160;&#160;0x0U</td></tr>
<tr class="separator:ga5c12c9f4560937e82ca07044f9f9ed78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga249aed20c9fca80c33b5ba5fd06e7dee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stl__crc.html#ga249aed20c9fca80c33b5ba5fd06e7dee">STL_CRC_FAIL</a>&#160;&#160;&#160;0x1U</td></tr>
<tr class="separator:ga249aed20c9fca80c33b5ba5fd06e7dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga5cb497e069bcca7769c1b6f9b6835557"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_s_t_l___c_r_c___obj.html">STL_CRC_Obj</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stl__crc.html#ga5cb497e069bcca7769c1b6f9b6835557">STL_CRC_Handle</a></td></tr>
<tr class="memdesc:ga5cb497e069bcca7769c1b6f9b6835557"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to the CRC structure.  <a href="#ga5cb497e069bcca7769c1b6f9b6835557">More...</a><br/></td></tr>
<tr class="separator:ga5cb497e069bcca7769c1b6f9b6835557"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:gacaffda81b063f3ee1f76d599b41cfcef"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stl__crc.html#gacaffda81b063f3ee1f76d599b41cfcef">STL_CRC_Parity</a> { <br/>
&#160;&#160;<a class="el" href="group__stl__crc.html#ggacaffda81b063f3ee1f76d599b41cfcefa5f6839023021f765f0259cca4784b5f5">STL_CRC_PARITY_EVEN</a> = 0U, 
<br/>
&#160;&#160;<a class="el" href="group__stl__crc.html#ggacaffda81b063f3ee1f76d599b41cfcefaea6d57dbcf9e8eef38dbc5abbf9a5fbe">STL_CRC_PARITY_ODD</a> = 1U
<br/>
 }</td></tr>
<tr class="memdesc:gacaffda81b063f3ee1f76d599b41cfcef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parity enumeration.  <a href="group__stl__crc.html#gacaffda81b063f3ee1f76d599b41cfcef">More...</a><br/></td></tr>
<tr class="separator:gacaffda81b063f3ee1f76d599b41cfcef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gac5473597805ddfc87225bffb961cc1d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stl__crc.html#gac5473597805ddfc87225bffb961cc1d5">STL_CRC_reset</a> (void)</td></tr>
<tr class="memdesc:gac5473597805ddfc87225bffb961cc1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Workaround to the silicon issue of first VCU calculation on power up being erroneous.  <a href="#gac5473597805ddfc87225bffb961cc1d5">More...</a><br/></td></tr>
<tr class="separator:gac5473597805ddfc87225bffb961cc1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabece331773db5d74d71d1792b2e21b61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stl__crc.html#gabece331773db5d74d71d1792b2e21b61">STL_CRC_calculate</a> (const <a class="el" href="group__stl__crc.html#ga5cb497e069bcca7769c1b6f9b6835557">STL_CRC_Handle</a> crcHandle)</td></tr>
<tr class="memdesc:gabece331773db5d74d71d1792b2e21b61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the 32-bit CRC routine using polynomial 0x04c11db7.  <a href="#gabece331773db5d74d71d1792b2e21b61">More...</a><br/></td></tr>
<tr class="separator:gabece331773db5d74d71d1792b2e21b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4980d0cc1cce768635cbbd6d36a5ae3e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stl__crc.html#ga4980d0cc1cce768635cbbd6d36a5ae3e">STL_CRC_calculateLowBytes</a> (const <a class="el" href="group__stl__crc.html#ga5cb497e069bcca7769c1b6f9b6835557">STL_CRC_Handle</a> crcHandle)</td></tr>
<tr class="memdesc:ga4980d0cc1cce768635cbbd6d36a5ae3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Runs the 32-bit CRC routine using polynomial 0x04c11db7.  <a href="#ga4980d0cc1cce768635cbbd6d36a5ae3e">More...</a><br/></td></tr>
<tr class="separator:ga4980d0cc1cce768635cbbd6d36a5ae3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2344e034072d2e227fa179981de2d543"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__stl__crc.html#ga2344e034072d2e227fa179981de2d543">STL_CRC_checkCRC</a> (const uint32_t startAddress, const uint32_t endAddress, const uint32_t goldenCRC)</td></tr>
<tr class="memdesc:ga2344e034072d2e227fa179981de2d543"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates a CRC-32 value for specific memory range and compares it with the goldenCRC value.  <a href="#ga2344e034072d2e227fa179981de2d543">More...</a><br/></td></tr>
<tr class="separator:ga2344e034072d2e227fa179981de2d543"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The code for this module is contained in <code>source/stl_crc.c</code> and <code>source/stl_crc_s.asm</code> (F2837x only), with <code><a class="el" href="stl__crc_8h.html">include/stl_crc.h</a></code> containing the API declarations for use by applications. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="gaa767de3bcc0ddcc991684de95fd7a763"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STL_CRC_INIT_CRC&#160;&#160;&#160;0x0UL</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initial CRC Register Value. </p>

</div>
</div>
<a class="anchor" id="ga5c12c9f4560937e82ca07044f9f9ed78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STL_CRC_PASS&#160;&#160;&#160;0x0U</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ga249aed20c9fca80c33b5ba5fd06e7dee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define STL_CRC_FAIL&#160;&#160;&#160;0x1U</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ga5cb497e069bcca7769c1b6f9b6835557"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_s_t_l___c_r_c___obj.html">STL_CRC_Obj</a>* <a class="el" href="group__stl__crc.html#ga5cb497e069bcca7769c1b6f9b6835557">STL_CRC_Handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Handle to the CRC structure. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="gacaffda81b063f3ee1f76d599b41cfcef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__stl__crc.html#gacaffda81b063f3ee1f76d599b41cfcef">STL_CRC_Parity</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parity enumeration. </p>
<p>The parity is used by the CRC algorithm to determine whether to begin calculations from the low byte (EVEN) or from the high byte (ODD) of the first word (16-bit) in the message. <br/>
 For example, if your message had 10 bytes and started at the address 0x8000 but the first byte was at the high byte position of the first 16-bit word, the user would call the CRC function with odd parity i.e. STL_CRC_PARITY_ODD <br/>
 Address: HI LO <br/>
 0x8000 : B0 XX <br/>
 0x8001 : B2 B1 <br/>
 0x8002 : B4 B3 <br/>
 0x8003 : B6 B5 <br/>
 0x8004 : B8 B7 <br/>
 0x8005 : XX B9 <br/>
 However, if the first byte was at the low byte position of the first 16-bit word, the user would call the CRC function with even parity i.e. STL_CRC_PARITY_EVEN <br/>
 Address: HI LO <br/>
 0x8000 : B1 B0 <br/>
 0x8001 : B3 B2 <br/>
 0x8002 : B5 B4 <br/>
 0x8003 : B7 B6 <br/>
 0x8004 : B9 B8 <br/>
 </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ggacaffda81b063f3ee1f76d599b41cfcefa5f6839023021f765f0259cca4784b5f5"></a>STL_CRC_PARITY_EVEN</em>&nbsp;</td><td class="fielddoc">
<p>Even parity, CRC starts at the low byte of the first word (16-bit) </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ggacaffda81b063f3ee1f76d599b41cfcefaea6d57dbcf9e8eef38dbc5abbf9a5fbe"></a>STL_CRC_PARITY_ODD</em>&nbsp;</td><td class="fielddoc">
<p>Odd parity, CRC starts at the high byte of the first word (16-bit) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac5473597805ddfc87225bffb961cc1d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void STL_CRC_reset </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname">)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Workaround to the silicon issue of first VCU calculation on power up being erroneous. </p>
<p>Due to the internal power-up state of the VCU module, it is possible that the first CRC result will be incorrect. This condition applies to the first result from each of the eight CRC instructions. This rare condition can only occur after a power-on reset, but will not necessarily occur on every power on. A warm reset will not cause this condition to reappear.</p>
<p>Workaround(s): The application can reset the internal VCU CRC logic by performing a CRC calculation of a single byte in the initialization routine. This routine only needs to perform one CRC calculation and can use any of the CRC instructions.</p>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="gabece331773db5d74d71d1792b2e21b61"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void STL_CRC_calculate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__stl__crc.html#ga5cb497e069bcca7769c1b6f9b6835557">STL_CRC_Handle</a>&#160;</td>
          <td class="paramname"><em>crcHandle</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs the 32-bit CRC routine using polynomial 0x04c11db7. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crcHandle</td><td>handle to the CRC object</td></tr>
  </table>
  </dd>
</dl>
<p>Calculates the 32-bit CRC using polynomial 0x04c11db7 on the VCU or VCRC. Depending on the parity chosen the CRC begins at either the low byte (STL_CRC_PARITY_EVEN) or the high byte (STL_CRC_PARITY_ODD) of the first word (16-bit).</p>
<dl class="section note"><dt>Note</dt><dd>The size of the message (bytes) is limited to 65535 bytes.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga4980d0cc1cce768635cbbd6d36a5ae3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void STL_CRC_calculateLowBytes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__stl__crc.html#ga5cb497e069bcca7769c1b6f9b6835557">STL_CRC_Handle</a>&#160;</td>
          <td class="paramname"><em>crcHandle</em>)</td><td></td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Runs the 32-bit CRC routine using polynomial 0x04c11db7. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">crcHandle</td><td>handle to the CRC object</td></tr>
  </table>
  </dd>
</dl>
<p>Calculates the 32-bit CRC using polynomial 0x04c11db7 on the VCU or VCRC. This algorithm performs a CRC32 only on the low bytes (LSB) of each 16-bit word. The input <b>parity</b> has no effect. This function works on unpacked data.</p>
<dl class="section note"><dt>Note</dt><dd>The size of the message (bytes) is limited to 65535 bytes.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a class="anchor" id="ga2344e034072d2e227fa179981de2d543"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t STL_CRC_checkCRC </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>startAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>endAddress</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint32_t&#160;</td>
          <td class="paramname"><em>goldenCRC</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates a CRC-32 value for specific memory range and compares it with the goldenCRC value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">startAddress</td><td>- start address of CRC calculation. </td></tr>
    <tr><td class="paramname">endAddress</td><td>- end address of CRC calculation, inclusive. </td></tr>
    <tr><td class="paramname">goldenCRC</td><td>- golden CRC value.</td></tr>
  </table>
  </dd>
</dl>
<p>This function performs a test of the memory range by calculating the CRC-32 value for the input memory range and comparing it with the golden CRC value.</p>
<dl class="section note"><dt>Note</dt><dd>This function could be used with many memory types including Flash and Boot ROM.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>If the calculated CRC matches the golden CRC, then the function returns <b>STL_CRC_PASS</b>. Otherwise, it returns <b>STL_CRC_FAIL</b>. </dd></dl>

</div>
</div>
</div><!-- contents -->
<hr size="1" /><small>
Copyright  2021, Texas Instruments Incorporated</small>
</body>
</html>
